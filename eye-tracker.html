<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Eye & Head Combined Gaze — MediaPipe Tasks FaceLandmarker</title>
<style>
  :root{ --bg:#0b1220; --panel:#121a2a; --text:#e6eefb; --accent:#7cc0ff; --good:#7CFF9C; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  #overlay{ position:fixed; inset:0; pointer-events:none; z-index:10020; }
  #cursor{ position:fixed; width:18px; height:18px; margin:-9px 0 0 -9px; border-radius:999px; background:var(--accent); box-shadow:0 0 0 4px rgba(124,192,255,.25); }
  #ring,#ringFill{ position:fixed; width:42px; height:42px; margin:-21px 0 0 -21px; border-radius:999px; }
  #ring{border:3px solid rgba(255,255,255,.15)} #ringFill{box-shadow:0 0 0 3px var(--good) inset; clip-path: conic-gradient(var(--good) 0deg, transparent 0deg)}
  .calibDot{ position:absolute; width:18px; height:18px; margin:-9px 0 0 -9px; border-radius:50%; background:#FFD37C; box-shadow:0 0 0 6px rgba(255,211,124,.2) }
  #keyboard{ position:fixed; left:0; right:0; bottom:0; background:#0f172a; border-top:1px solid #1f2a42; display:grid; grid-template-columns:repeat(10,1fr); gap:8px; padding:12px; }
  .key{ user-select:none; display:flex; align-items:center; justify-content:center; height:56px; border-radius:12px; background:#16203a; color:#cfe3ff; border:1px solid #263a6b; font-weight:600 }
  .key.big{grid-column:span 2}.key.extra{grid-column:span 3}.key.active{outline:2px solid var(--accent)}
  .key.candidate{ outline:2px dashed var(--good); } /* blink candidate highlight */
  #status{ position:fixed; right:12px; top:12px; background:#121a2a; border:1px solid #203059; padding:8px 10px; border-radius:8px; z-index:10000}
  video,canvas{display:none}
  /* typed output */
  #typedBox{position:fixed; left:12px; right:12px; top:60px; background:#0f172a;
    border:1px solid #203059; padding:10px 12px; border-radius:10px; min-height:40px;
    font-size:18px; letter-spacing:.5px; white-space:pre-wrap; z-index:10000}
  #caret{opacity:.7; margin-left:2px; animation:blink .9s step-end infinite}
  @keyframes blink { 50% { opacity:0 } }
  /* prediction bar */
  #predictBar{ position:fixed; left:12px; right:12px; background:#0f172a; border:1px solid #203059;
    padding:8px; border-radius:10px; display:grid; grid-template-columns:repeat(3,1fr); gap:8px; z-index:10000 }
  #predictBar .key{ height:88px; font-weight:600; }
  /* small button to enable sound */
  #soundBtn{ position:fixed; left:12px; top:12px; z-index:10001; background:#16203a; color:#cfe3ff; border:1px solid #263a6b; border-radius:8px; padding:6px 10px; cursor:pointer }
</style>
</head>
<body>
  <video id="cam" autoplay playsinline muted></video>
  <canvas id="proc" width="640" height="480"></canvas>

  <div id="overlay">
    <div id="cursor"></div>
    <div id="ring"></div>
    <div id="ringFill"></div>
  </div>

  <div id="predictBar" aria-label="Predictions"></div>
  <div id="keyboard"></div>
  <div id="status">Status: <span id="statTxt">loading model…</span></div>
  <div id="typedBox"><span id="typedText"></span><span id="caret">|</span></div>
  <button id="soundBtn" title="Enable Sound">🔊 sound</button>

<script type="module">
const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3');
const { FaceLandmarker, FilesetResolver } = vision;

const cam = document.getElementById('cam');
const proc = document.getElementById('proc');
const ctx  = proc.getContext('2d');
const overlay = document.getElementById('overlay');
const cursor = document.getElementById('cursor');
const ring = document.getElementById('ring');
const ringFill = document.getElementById('ringFill');
const statTxt = document.getElementById('statTxt');
const keyboard = document.getElementById('keyboard');
const predictBar = document.getElementById('predictBar');
const soundBtn = document.getElementById('soundBtn');
const typedTextEl = document.getElementById('typedText');
let typedBuffer = '';
function renderTyped(){ typedTextEl.textContent = typedBuffer; }

const LAYOUT = ['QWERTYUIOP','ASDFGHJKL','ZXCVBNM'];
function buildKeyboard(){
  keyboard.innerHTML='';
  for(const ch of LAYOUT[0]) addKey(ch);
  const spacer = document.createElement('div'); spacer.style.opacity=0; keyboard.appendChild(spacer);
  for(const ch of LAYOUT[1]) addKey(ch);
  const spacer2 = document.createElement('div'); spacer2.style.opacity=0; keyboard.appendChild(spacer2);
  for(const ch of LAYOUT[2]) addKey(ch);
  addKey('SPACE','extra'); addKey('BKSP','big'); addKey('ENTER','big');
  positionPredictBar();
}
function addKey(label, cls=''){ const d=document.createElement('div'); d.className='key '+cls; d.dataset.label=label; d.textContent=label; keyboard.appendChild(d); }
buildKeyboard();

const wait = ms=>new Promise(r=>setTimeout(r,ms));

const COMMON_WORDS = [
  "the","to","and","you","that","was","for","are","with","have","this","not","but","they","his","her","she","from","had","say","who",
  "about","would","there","their","what","when","which","can","more","if","do","will","so","no","we","one","all","out","up","as",
  "on","in","at","it","is","be","of","or","by","an","he","me","my","your","our","like","time","just","know","good","people","now",
  "new","into","over","back","only","other","than","first","day","how","make","take","look","use","work","even","want","because",
  "any","could","should","very","also","between","after","before","again","little","great","right","left","top","bottom","yes","no"
];
function positionPredictBar(){
  const kbRect = keyboard.getBoundingClientRect();
  const bottomOffset = window.innerHeight - kbRect.top + 8;
  predictBar.style.bottom = bottomOffset + 'px';
}
window.addEventListener('resize', positionPredictBar);

function lastToken(){
  const m = typedBuffer.match(/([A-Za-z]+)$/);
  return m ? m[1] : '';
}
function updatePredictions(){
  predictBar.innerHTML = '';
  const token = lastToken().toLowerCase();
  let picks = [];
  if (token.length >= 1){
    picks = COMMON_WORDS.filter(w=>w.startsWith(token)).slice(0,3);
  } else {
    picks = COMMON_WORDS.slice(0,3);
  }
  for(const w of picks){
    const el = document.createElement('div');
    el.className = 'key pred';
    el.dataset.type = 'word';
    el.dataset.label = w;
    el.textContent = w;
    predictBar.appendChild(el);
  }
}

let audioCtx = null;
soundBtn.addEventListener('click', ()=>{
  try{
    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    statTxt.textContent = 'sound on ✓';
  }catch(e){ statTxt.textContent = 'sound blocked'; }
});
function beep(freq=660, dur=0.06, vol=0.06){
  if(!audioCtx) return;
  const t0 = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.frequency.value = freq;
  osc.type = 'sine';
  gain.gain.setValueAtTime(0, t0);
  gain.gain.linearRampToValueAtTime(vol, t0+0.005);
  gain.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start(t0); osc.stop(t0+dur+0.02);
}
function keyClickSound(){ beep(720, 0.06, 0.07); }
function wordClickSound(){ beep(480, 0.10, 0.09); }

/* ---------- dwell + snapping ---------- */
const DWELL_MS = 500;
const SNAP_RADIUS = 44;                 // easier acquire (was 28)
let hoverKey=null, hoverStart=0;

function centerDist(el, x, y){
  const r = el.getBoundingClientRect();
  const cx = (r.left+r.right)/2, cy = (r.top+r.bottom)/2;
  const d = Math.hypot(x-cx, y-cy);
  return {cx, cy, d};
}
function findNearestKey(x,y, R, biasWords=true){
  let best=null, bestScore=Infinity, bestRaw=Infinity;
  const els = document.querySelectorAll('.key');
  for(const k of els){
    const {d} = centerDist(k, x, y);
    const bias = (biasWords && k.dataset.type==='word') ? 0.7 : 1.0;
    const score = d * bias;
    if (score < bestScore){ bestScore = score; bestRaw = d; best = k; }
  }
  return (R==null || bestRaw<=R) ? best : null;
}
const MAGNET_RADIUS_KEY  = 100;   // was 100
const MAGNET_RADIUS_WORD = 180;   // was 180
const RELEASE_FACTOR     = 1.5;  // was 1.5
const USE_DWELL = false;          // blink-only click; keep highlight
const CLICK_DIST_KEY  = 100;  // px
const CLICK_DIST_WORD = 160;  // px
let snappedEl = null;

function snapPoint(x, y){
  let cand = findNearestKey(x, y, null, true);
  let resultX = x, resultY = y;
  if (snappedEl){
    const {d:sd} = centerDist(snappedEl, x, y);
    const sRad = (snappedEl.dataset.type==='word') ? MAGNET_RADIUS_WORD : MAGNET_RADIUS_KEY;
    if (sd > sRad * RELEASE_FACTOR) snappedEl = null; else cand = snappedEl;
  }
  if (!snappedEl && cand){
    const {cx, cy, d} = centerDist(cand, x, y);
    const rad = (cand.dataset.type==='word') ? MAGNET_RADIUS_WORD : MAGNET_RADIUS_KEY;
    if (d <= rad){ snappedEl = cand; resultX = cx; resultY = cy; }
  }
  if (snappedEl){
    const {cx, cy} = centerDist(snappedEl, x, y);
    resultX = cx; resultY = cy;
  }
  return { sx: resultX, sy: resultY, el: snappedEl || cand };
}

function selectKey(k){
  const isWord = k.dataset.type === 'word';
  const label = k.dataset.label;
  if (isWord){
    const m = typedBuffer.match(/^(.*?)([A-Za-z]+)?$/s);
    const head = m ? (m[1] || '') : typedBuffer;
    typedBuffer = head + label + ' ';
    renderTyped(); updatePredictions(); wordClickSound();
    statTxt.textContent = `Word: ${label}`;
    return;
  }
  if (label === 'SPACE')      { typedBuffer += ' '; statTxt.textContent = 'Inserted: ␣'; }
  else if (label === 'BKSP')  { typedBuffer = typedBuffer.slice(0, -1); statTxt.textContent = 'Backspace ⌫'; }
  else if (label === 'ENTER') { typedBuffer += '\n'; statTxt.textContent = 'Inserted: ↵'; }
  else                        { typedBuffer += label; statTxt.textContent = `Inserted: ${label}`; }
  renderTyped(); updatePredictions(); keyClickSound();
}
function setCursor(x,y,p=0){
  cursor.style.left=x+'px'; cursor.style.top=y+'px';
  ring.style.left=x+'px'; ring.style.top=y+'px';
  ringFill.style.left=x+'px'; ringFill.style.top=y+'px';
  ringFill.style.clipPath = `conic-gradient(var(--good) ${Math.round(p*360)}deg, transparent 0deg)`;
}
function updateDwell(xs, ys){
  const  sx = xs, sy = ys;
  const candidate = findNearestKey(sx, sy, null, true);
  const isClose  = candidate ? (centerDist(candidate, sx, sy).d <= SNAP_RADIUS) : false;
  const nearest  = isClose ? candidate : null;

  if (nearest !== hoverKey){
    if(hoverKey) hoverKey.classList.remove('active');
    hoverKey = candidate;                          // always highlight current candidate
    hoverStart = isClose ? performance.now() : 0;  // dwell only if close
    setCursor(sx, sy, 0);
    if(hoverKey) hoverKey.classList.add('active');
    return;
  }
  if (!hoverKey) { setCursor(sx, sy, 0); return; }

  const p = isClose ? Math.min(1, (performance.now()-hoverStart)/DWELL_MS) : 0;
  setCursor(sx, sy, p);

  if (p >= 1 && USE_DWELL){
    selectKey(hoverKey);
    hoverKey.classList.remove('active');
    hoverKey = null; hoverStart = 0;
    setCursor(sx, sy, 0);
  }
}

/* ---------- OneEuro filter ---------- */
class OneEuro {
  constructor(minCutoff=1.0, beta=0.006, dCutoff=1.0, freq=60){
    this.minCutoff=minCutoff; this.beta=beta; this.dCutoff=dCutoff; this.freq=freq;
    this.xPrev=null; this.dxPrev=0; this.tPrev=null;
  }
  alpha(cutoff){ const te=1.0/this.freq; const r=2*Math.PI*cutoff*te; return r/(r+1); }
  update([x,y]){
    const now=performance.now();
    const dt=this.tPrev? (now-this.tPrev)/1000 : 1/this.freq; this.tPrev=now;
    const aD=this.alpha(this.dCutoff);
    const dx = this.xPrev? Math.hypot(x-this.xPrev[0], y-this.xPrev[1]) / dt : 0;
    const dxHat = aD*dx + (1-aD)*this.dxPrev; this.dxPrev=dxHat;
    const cutoff = this.minCutoff + this.beta*dxHat;
    const a = this.alpha(cutoff);
    const xHat = this.xPrev? [ a*x + (1-a)*this.xPrev[0], a*y + (1-a)*this.xPrev[1] ] : [x,y];
    this.xPrev = xHat; return xHat;
  }
}
const filter = new OneEuro(1.0, 0.006, 1.0, 60);

/* ---------- calibration ---------- */
const calibPairs=[];
const targets=[[0.1,0.1],[0.5,0.1],[0.9,0.1],[0.1,0.5],[0.5,0.5],[0.9,0.5],[0.1,0.9],[0.5,0.9],[0.9,0.9]];
const margin=40;
const pxX = tx=> margin + tx*(innerWidth-2*margin);
const pxY = ty=> margin + ty*(innerHeight-2*margin);
function showDotAt(tx,ty){
  const x=pxX(tx), y=pxY(ty);
  const d=document.createElement('div'); d.className='calibDot';
  d.style.left=x+'px'; d.style.top=y+'px'; overlay.appendChild(d);
  return {x,y,el:d};
}
let theta=null;
let uBias = JSON.parse(localStorage.getItem('uBias') || '[0,0]');
const phi = ([a,b])=> [1,a,b,a*a,a*b,b*b];
function fitMapping(pairs){
  const Phi=pairs.map(p=>phi(p.u)), Y=pairs.map(p=>p.v);
  const d=6, m=Phi.length, A=Array.from({length:d},()=>Array(d).fill(0)), B=Array.from({length:d},()=>Array(2).fill(0));
  for(let i=0;i<m;i++){ const ph=Phi[i], y=Y[i];
    for(let r=0;r<d;r++){ for(let c=0;c<d;c++) A[r][c]+= ph[r]*ph[c]; B[r][0]+= ph[r]*y[0]; B[r][1]+= ph[r]*y[1]; } }
  function solve(col){ const n=d, M=A.map((row,i)=>row.slice().concat(B[i][col]));
    for(let i=0;i<n;i++){ let piv=i; for(let r=i+1;r<n;r++) if(Math.abs(M[r][i])>Math.abs(M[piv][i])) piv=r;
      [M[i],M[piv]]=[M[piv],M[i]]; const div=M[i][i]||1e-9; for(let c=i;c<=n;c++) M[i][c]/=div;
      for(let r=0;r<n;r++){ if(r===i) continue; const f=M[r][i]; for(let c=i;c<=n;c++) M[r][c]-=f*M[i][c]; } }
  return M.map(row=>row[n]); }
  theta=[solve(0), solve(1)]; localStorage.setItem('calibTheta', JSON.stringify(theta));
}
function mapToScreen(u){
  if(!theta){ const cx=innerWidth*0.5, cy=innerHeight*0.5; return [cx + u[0]*220, cy + u[1]*220]; }
  const p=phi(u); const x=p.reduce((s,v,i)=>s+v*theta[0][i],0), y=p.reduce((s,v,i)=>s+v*theta[1][i],0); return [x,y];
}
async function runCalibration(){
  statTxt.textContent='calibrating…';
  const S=30, dt=60;
  for(const [tx,ty] of targets){
    const dot=showDotAt(tx,ty); await wait(400);
    for(let i=0;i<S;i++){ if(lastU) calibPairs.push({u:lastU.slice(), v:[dot.x,dot.y]}); await wait(dt); }
    dot.el.remove(); await wait(120);
  }
  fitMapping(calibPairs); statTxt.textContent='running (calibrated ✓)'; localStorage.setItem('calibrated','1');
}

/* ---------- camera ---------- */
const constraints = { video: { facingMode: 'user', width: 640, height: 480 } };
const startCamera = async ()=>{
  const stream = await navigator.mediaDevices.getUserMedia(constraints);
  cam.srcObject = stream;
  await cam.play();
  if(!cam.videoWidth || !cam.videoHeight){
    await new Promise(res => cam.addEventListener('loadedmetadata', res, { once:true }));
  }
  cam.style.display='block';
  cam.style.position='fixed';
  cam.style.left='0'; cam.style.top='0';
  cam.style.width='1px'; cam.style.height='1px'; cam.style.opacity='0';
  cam.style.transform='scaleX(-1)';
  proc.width = cam.videoWidth || 640;
  proc.height = cam.videoHeight || 480;
  console.log('video dims:', cam.videoWidth, cam.videoHeight);
};

/* ---------- face landmarker ---------- */
let faceLandmarker=null, runningMode='VIDEO';
async function loadLandmarker(){
  const filesetResolver = await FilesetResolver.forVisionTasks(
    'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm'
  );
  faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
    baseOptions: {
      modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
      delegate: 'GPU'
    },
    runningMode: runningMode,
    numFaces: 1,
    outputFaceBlendshapes: false,
    outputFacialTransformationMatrixes: false
  });
}

/* ---------- gaze feature ---------- */
const IDX = {
  R_OUT: 33, R_IN: 133, L_OUT: 362, L_IN: 263,
  R_UP: 159, R_LO: 145, L_UP: 386, L_LO: 374,
  RIGHT_IRIS: [469,470,471,472], LEFT_IRIS: [474,475,476,477],
  NOSE: 1
};
function avgPts(landmarks, idxs){
  let sx=0, sy=0, c=0;
  for(const i of idxs){ const p=landmarks[i]; if(p){ sx+=p.x; sy+=p.y; c++; } }
  return c ? {x:sx/c, y:sy/c} : {x:NaN, y:NaN};
}
function computeCombinedFeature(landmarks){
  const N = landmarks.length;
  const Rc = (N>=478) ? avgPts(landmarks, IDX.RIGHT_IRIS) : avgPts(landmarks, [IDX.R_UP, IDX.R_LO]);
  const Lc = (N>=478) ? avgPts(landmarks, IDX.LEFT_IRIS)  : avgPts(landmarks, [IDX.L_UP, IDX.L_LO]);

  const Router = landmarks[IDX.R_OUT], Rinner = landmarks[IDX.R_IN];
  const Louter = landmarks[IDX.L_OUT], Linner = landmarks[IDX.L_IN];
  const Rmid = {x:(Router.x+Rinner.x)/2, y:(Router.y+Rinner.y)/2};
  const Lmid = {x:(Louter.x+Linner.x)/2, y:(Louter.y+Linner.y)/2};
  const Rw = Math.hypot(Router.x-Rinner.x, Router.y-Rinner.y) + 1e-6;
  const Lw = Math.hypot(Louter.x-Linner.x, Louter.y-Linner.y) + 1e-6;

  const Rup = landmarks[IDX.R_UP], Rlo = landmarks[IDX.R_LO];
  const Lup = landmarks[IDX.L_UP], Llo = landmarks[IDX.L_LO];
  const RmidY = (Rup.y + Rlo.y)/2, LmidY = (Lup.y + Llo.y)/2;
  const Rh_raw = Math.abs(Rup.y - Rlo.y);
  const Lh_raw = Math.abs(Lup.y - Llo.y);
  const Rh = Math.max(Rh_raw, 0.25*Rw) + 1e-6; // robust near blink
  const Lh = Math.max(Lh_raw, 0.25*Lw) + 1e-6;

  const ux_eye = -((Rc.x - Rmid.x)/Rw + (Lc.x - Lmid.x)/Lw) * 0.5;
  const uy_eye = ((Rc.y - RmidY)/Rh + (Lc.y - LmidY)/Lh) * 0.5;

  const REc = {x:(Router.x+Rinner.x)/2, y:(Router.y+Rinner.y)/2};
  const LEc = {x:(Louter.x+Linner.x)/2, y:(Louter.y+Linner.y)/2};
  const eyeCenter = {x:(REc.x+LEc.x)/2, y:(REc.y+LEc.y)/2};

  let minY=+Infinity, maxY=-Infinity, minX=+Infinity, maxX=-Infinity;
  for(const p of landmarks){ if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; }
  const faceH = Math.max(1e-6, maxY - minY);
  const eyeSpan = Math.hypot(REc.x-LEc.x, REc.y-LEc.y) + 1e-6;

  const nose = landmarks[IDX.NOSE] || eyeCenter;
  let ux_head = (nose.x - eyeCenter.x)/eyeSpan;
  let uy_head = (nose.y - eyeCenter.y)/faceH;
  ux_head = -ux_head;

  const ux = (1.4*ux_eye + 1.4*ux_head) * 8;
  const uy = (-1.4*uy_eye + 1.4*uy_head) * 6;
  return [ux, uy];
}

/* ---------- blink (dynamic thresholds + derivative freeze) ---------- */
let BLINK_CONFIRM = true;
let BLINK_LOW_BASE  = 0.045;
let BLINK_HIGH_BASE = 0.085;
const BLINK_MIN_MS = 80;
const BLINK_MAX_MS = 600;
const BLINK_COOLDOWN_MS = 500;
const BLINK_RANGE = 120;

let blinkState = { closed:false, t0:0, lastConfirm:0, cooldownUntil:0, justClosed:false };
let pendingBlinkSelect = false;
let blinkCandidate = null;
let earBelowFrames = 0, earAboveFrames = 0;
const ENTER_FRAMES = 2, EXIT_FRAMES = 2;

let prevEar = null;
let earOpenEMA = 0;
const EAR_DROP_FREEZE = 0.020;   // freeze on fast closing

function computeEAR(lm){
  const R_OUT=33, R_IN=133, R_UP=159, R_LO=145;
  const L_OUT=362, L_IN=263, L_UP=386, L_LO=374;
  const Router=lm[R_OUT], Rinner=lm[R_IN], Rup=lm[R_UP], Rlo=lm[R_LO];
  const Louter=lm[L_OUT], Linner=lm[L_IN], Lup=lm[L_UP], Llo=lm[L_LO];
  const Rw = Math.hypot(Router.x-Rinner.x, Router.y-Rinner.y) + 1e-6;
  const Lw = Math.hypot(Louter.x-Linner.x, Louter.y-Linner.y) + 1e-6;
  const gapR = Math.abs(Rup.y - Rlo.y) / Rw;
  const gapL = Math.abs(Lup.y - Llo.y) / Lw;
  return (gapR + gapL) * 0.5;
}
function setBlinkCandidate(el){
  if (blinkCandidate === el) return;
  if (blinkCandidate) blinkCandidate.classList.remove('candidate');
  blinkCandidate = el;
  if (blinkCandidate) blinkCandidate.classList.add('candidate');
}

/* ---------- main loop ---------- */
const filter1 = new OneEuro(1.0, 0.003, 1.0, 60);
let lastU=[0,0], lastVideoTime=-1;
let lastSnapEl = null;

async function tick(){
  ctx.drawImage(cam, 0, 0, proc.width, proc.height);
  const now = performance.now();
  if (cam.currentTime !== lastVideoTime && faceLandmarker){
    lastVideoTime = cam.currentTime;
    const results = faceLandmarker.detectForVideo(cam, now);

    if (results?.faceLandmarks?.length){
      const lm = results.faceLandmarks[0];
      let u = computeCombinedFeature(lm);

      // EAR + dynamic thresholds
      const ear = computeEAR(lm);
      if (!blinkState.closed && ear > BLINK_HIGH_BASE) {
        earOpenEMA = earOpenEMA ? (0.9*earOpenEMA + 0.1*ear) : ear;
      }
      const BLINK_LOW_EFF  = Math.max(BLINK_LOW_BASE,  earOpenEMA ? earOpenEMA*0.62 : BLINK_LOW_BASE);
      const BLINK_HIGH_EFF = Math.max(BLINK_HIGH_BASE, BLINK_LOW_EFF + 0.015);
      const EAR_FREEZE_EFF = BLINK_LOW_EFF + 0.020;

      // pre-blink derivative freeze to prevent jump
      if (prevEar !== null && (prevEar - ear) > EAR_DROP_FREEZE) {
        u = lastU.slice();
      }

      // Debounced blink FSM
      const t = now;
      if (!blinkState.closed) {
        if (ear < BLINK_LOW_EFF) {
          if (++earBelowFrames >= ENTER_FRAMES) {
            blinkState.closed = true; blinkState.t0 = t; blinkState.justClosed = true; earAboveFrames = 0;
          }
        } else earBelowFrames = 0;
      } else {
        if (ear > BLINK_HIGH_EFF) {
          if (++earAboveFrames >= EXIT_FRAMES) {
            const dur = t - blinkState.t0;
            blinkState.closed = false; blinkState.justClosed = false;
            blinkState.cooldownUntil = t + BLINK_COOLDOWN_MS;
            if (dur >= BLINK_MIN_MS && dur <= BLINK_MAX_MS && (t - blinkState.lastConfirm) > 400) {
              if (BLINK_CONFIRM) pendingBlinkSelect = true;
              blinkState.lastConfirm = t;
            }
            earBelowFrames = 0;
          }
        } else earAboveFrames = 0;
      }

      // Freeze during near-close/closed/cooldown
      if (ear < EAR_FREEZE_EFF || blinkState.closed || now < blinkState.cooldownUntil) {
        u = lastU.slice();
      }
      lastU = u;
      prevEar = ear;

      if (Number.isFinite(u[0]) && Number.isFinite(u[1])){
        const [x,y]   = mapToScreen(u);
        const [xs,ys] = filter1.update([x,y]);
        if (Number.isFinite(xs) && Number.isFinite(ys)){
          const snap = snapPoint(xs, ys);
          const { sx, sy, el } = snap;
          lastSnapEl = el;

          setCursor(sx, sy, hoverKey ? Math.min(1, (performance.now()-hoverStart)/DWELL_MS) : 0);
          updateDwell(sx, sy);

          // Lock candidate at blink start to the *pre-blink* element
          if (blinkState.closed && blinkState.justClosed) {
            setBlinkCandidate(lastSnapEl || findNearestKey(sx, sy, BLINK_RANGE, true));
            blinkState.justClosed = false;
          } else if (!blinkState.closed && now >= blinkState.cooldownUntil) {
            setBlinkCandidate(null);
          }

          if (pendingBlinkSelect) {
            const candidate = blinkCandidate || findNearestKey(sx, sy, null, true);
            let ok = false;

            if (candidate) {
                const { d } = centerDist(candidate, sx, sy);
                const thresh = candidate.dataset.type === 'word' ? CLICK_DIST_WORD : CLICK_DIST_KEY;
                ok = d <= thresh;
            }

            if (ok) {
                selectKey(candidate);
                candidate.classList.remove('active');
            } else {
                // too far → no click
                statTxt.textContent = 'blink ignored (too far)';
            }

            setBlinkCandidate(null);
            hoverKey = null; hoverStart = 0; setCursor(sx, sy, 0);
            pendingBlinkSelect = false;
            }
        }
      }
    }
  }
  requestAnimationFrame(tick);
}

/* ---------- boot ---------- */
async function boot(){
  await startCamera();
  statTxt.textContent='loading face landmarker…';
  await loadLandmarker();
  statTxt.textContent='running';
  const saved = localStorage.getItem('calibTheta');
  if(saved){
    try{
      const t = JSON.parse(saved);
      const ok = t && t.length===2 && t[0].every(Number.isFinite) && t[1].every(Number.isFinite);
      if (ok) { theta = t; statTxt.textContent='running (calibrated ✓)'; }
      else { localStorage.removeItem('calibTheta'); theta=null; }
    }catch{ localStorage.removeItem('calibTheta'); theta=null; }
  }
  updatePredictions();
  requestAnimationFrame(() => {
    setCursor(window.innerWidth/2, window.innerHeight/2, 0);
  });
  requestAnimationFrame(tick);
}
boot();

/* ---------- hotkeys ---------- */
// c = calibration; r = recenter; x = clear calibration
window.addEventListener('keydown', e=>{ if(e.key==='c') runCalibration(); });
window.addEventListener('keydown', (e) => {
  if (e.key === 'r') {
    if (Array.isArray(lastU)) {
      uBias = lastU.slice();
      localStorage.setItem('uBias', JSON.stringify(uBias));
      statTxt.textContent = 'recentered (baseline set)';
    }
  }
});
window.addEventListener('keydown', e=>{
  if (e.key==='x'){
    localStorage.removeItem('calibTheta');
    theta = null;
    statTxt.textContent = 'calibration cleared';
  }
});
</script>
</body>
</html>
